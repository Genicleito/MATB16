}
cat("\t", tam.inicial - nrow(dataSet), " valores NA removidos.\n")
cat("\tPorcentagem de NAs removidos: ", 100 - (nrow(dataSet) * 100 / tam.inicial),"%\n")
return(dataSet)
}
removeOutliers <- function(dataSet){
inicial <- nrow(dataSet)
for(i in seq_along(dataSet[, -c(ncol(dataSet))])){
attrSemNa <- dataSet[, i][!is.na(dataSet[, i])]
# Boxplot antes de remover os Outliers
png(filename = paste(toString(names(dataSet[i])), ".png") )
boxplot(attrSemNa)
dev.off()
dataSet <- dataSet[!attrSemNa %in% boxplot.stats(attrSemNa)$out, ]
boxplot(attrSemNa)
#print(i)
}
cat("Outliers Removidos: ", inicial - nrow(dataSet), "\n")
cat("Total de instancias: ", inicial, "\n")
cat("InstÃ¢ncias atuais: ", nrow(dataSet), "\n")
cat("Numero colunas: ", ncol(dataSet), "\n")
cat("Porcentagem de outliers removidos: ", nrow(dataSet) * 100 / inicial,"%\n")
return(dataSet)
}
normalizar <- function(dataSet){
attrs <- c()
for(i in seq_along(dataSet[, -c(ncol(dataSet))])){
attrSemNA <- dataSet[, i][!is.na(dataSet[, i])]
minValue <- min(attrSemNA)
#print(minValue)
maxValue <- max(attrSemNA)
#print(maxValue)
if(maxValue - minValue != 0){
normAttr <- (attrSemNA - minValue) / (maxValue - minValue)
dataSet[, i] <- normAttr
cat("Normalizado: ", i, "\n")
}else{
attrs <- c(attrs, i)
}
}
print(attrs)
dataSet <- dataSet[ , -c(attrs)]
return(dataSet)
}
dados <- transformacao(dados)
dados <- removeNA(dados)
dados <- removeOutliers(dados)
write.csv(dados, file = "enemNumericoPre.csv", sep = ",", row.names = FALSE)
dados
dados <- read.table("enem_BA.data", sep = ",")
dados <- dados[which(dados$V1 == "BA"), ]
################# Inicio FunÃ§Ãµes #################
transformacao <- function(dataset){
for(i in seq_along(dataset)){
temp <- as.vector(dataset[, i])
# Se forem estados
temp[which(temp == "AC")] = "0"
temp[which(temp == "AL")] = "1"
temp[which(temp == "AM")] = "2"
temp[which(temp == "AP")] = "3"
temp[which(temp == "BA")] = "4"
temp[which(temp == "CE")] = "5"
temp[which(temp == "DF")] = "6"
temp[which(temp == "ES")] = "7"
temp[which(temp == "GO")] = "8"
temp[which(temp == "MA")] = "9"
temp[which(temp == "MG")] = "10"
temp[which(temp == "MS")] = "11"
temp[which(temp == "MT")] = "12"
temp[which(temp == "PA")] = "13"
temp[which(temp == "PB")] = "14"
temp[which(temp == "PE")] = "15"
temp[which(temp == "PI")] = "16"
temp[which(temp == "PR")] = "17"
temp[which(temp == "RJ")] = "18"
temp[which(temp == "RN")] = "19"
temp[which(temp == "RO")] = "20"
temp[which(temp == "RR")] = "21"
temp[which(temp == "RS")] = "22"
temp[which(temp == "SC")] = "23"
temp[which(temp == "SE")] = "24"
temp[which(temp == "SP")] = "25"
temp[which(temp == "TO")] = "26"
# Se for o sexo
temp[which(temp == 'F')] = "0"
temp[which(temp == 'M')] = "1"
# Se for a Q006
temp[which(temp == 'A')] = "0"
temp[which(temp == 'B')] = "1"
temp[which(temp == 'C')] = "2"
temp[which(temp == 'D')] = "3"
temp[which(temp == 'E')] = "4"
temp[which(temp == 'F')] = "5"
temp[which(temp == 'G')] = "6"
temp[which(temp == 'H')] = "7"
temp[which(temp == 'I')] = "8"
temp[which(temp == 'J')] = "9"
temp[which(temp == 'K')] = "10"
temp[which(temp == 'L')] = "11"
temp[which(temp == 'M')] = "12"
temp[which(temp == 'N')] = "13"
temp[which(temp == 'O')] = "14"
temp[which(temp == 'P')] = "15"
temp[which(temp == 'Q')] = "16"
# Se for a Q047 (acredito que seja desnecessÃ¡rio porque o cÃ³digo anterior jÃ¡ faz oq essas 5 linhas faz)
temp[which(temp == 'A')] = "0"
temp[which(temp == 'B')] = "1"
temp[which(temp == 'C')] = "2"
temp[which(temp == 'D')] = "3"
temp[which(temp == 'E')] = "4"
dataset[, i] <- as.integer(temp)
}
return(dataset)
}
removeNA <- function(dataSet){
tam.inicial <- nrow(dataSet)
for(i in seq_along(dataSet)){
dataSet <- dataSet[!is.na(dataSet[, i]), ]
#dataSet <- dataSet[attrSemNa, ]
#print(i)
}
cat("\t", tam.inicial - nrow(dataSet), " valores NA removidos.\n")
cat("\tPorcentagem de NAs removidos: ", 100 - (nrow(dataSet) * 100 / tam.inicial),"%\n")
return(dataSet)
}
removeOutliers <- function(dataSet){
inicial <- nrow(dataSet)
for(i in seq_along(dataSet[, -c(ncol(dataSet))])){
attrSemNa <- dataSet[, i][!is.na(dataSet[, i])]
# Boxplot antes de remover os Outliers
png(filename = paste(toString(names(dataSet[i])), ".png") )
boxplot(attrSemNa)
dev.off()
dataSet <- dataSet[!attrSemNa %in% boxplot.stats(attrSemNa)$out, ]
boxplot(attrSemNa)
#print(i)
}
cat("Outliers Removidos: ", inicial - nrow(dataSet), "\n")
cat("Total de instancias: ", inicial, "\n")
cat("InstÃ¢ncias atuais: ", nrow(dataSet), "\n")
cat("Numero colunas: ", ncol(dataSet), "\n")
cat("Porcentagem de outliers removidos: ", nrow(dataSet) * 100 / inicial,"%\n")
return(dataSet)
}
normalizar <- function(dataSet){
attrs <- c()
for(i in seq_along(dataSet[, -c(ncol(dataSet))])){
attrSemNA <- dataSet[, i][!is.na(dataSet[, i])]
minValue <- min(attrSemNA)
#print(minValue)
maxValue <- max(attrSemNA)
#print(maxValue)
if(maxValue - minValue != 0){
normAttr <- (attrSemNA - minValue) / (maxValue - minValue)
dataSet[, i] <- normAttr
cat("Normalizado: ", i, "\n")
}else{
attrs <- c(attrs, i)
}
}
print(attrs)
dataSet <- dataSet[ , -c(attrs)]
return(dataSet)
}
dados <- transformacao(dados)
dados <- removeNA(dados)
dados <- removeOutliers(dados)
dados
dados <- normalizar(dados)
write.csv(dados, file = "enemNumericoPre.csv", sep = ",", row.names = FALSE)
dados <- read.table("enem_BA.data", sep = ",")
dados <- dados[which(dados$V1 == "BA"), ]
################# Inicio FunÃ§Ãµes #################
transformacao <- function(dataset){
for(i in seq_along(dataset)){
temp <- as.vector(dataset[, i])
# Se forem estados
temp[which(temp == "AC")] = "0"
temp[which(temp == "AL")] = "1"
temp[which(temp == "AM")] = "2"
temp[which(temp == "AP")] = "3"
temp[which(temp == "BA")] = "4"
temp[which(temp == "CE")] = "5"
temp[which(temp == "DF")] = "6"
temp[which(temp == "ES")] = "7"
temp[which(temp == "GO")] = "8"
temp[which(temp == "MA")] = "9"
temp[which(temp == "MG")] = "10"
temp[which(temp == "MS")] = "11"
temp[which(temp == "MT")] = "12"
temp[which(temp == "PA")] = "13"
temp[which(temp == "PB")] = "14"
temp[which(temp == "PE")] = "15"
temp[which(temp == "PI")] = "16"
temp[which(temp == "PR")] = "17"
temp[which(temp == "RJ")] = "18"
temp[which(temp == "RN")] = "19"
temp[which(temp == "RO")] = "20"
temp[which(temp == "RR")] = "21"
temp[which(temp == "RS")] = "22"
temp[which(temp == "SC")] = "23"
temp[which(temp == "SE")] = "24"
temp[which(temp == "SP")] = "25"
temp[which(temp == "TO")] = "26"
# Se for o sexo
temp[which(temp == 'F')] = "0"
temp[which(temp == 'M')] = "1"
# Se for a Q006
temp[which(temp == 'A')] = "0"
temp[which(temp == 'B')] = "1"
temp[which(temp == 'C')] = "2"
temp[which(temp == 'D')] = "3"
temp[which(temp == 'E')] = "4"
temp[which(temp == 'F')] = "5"
temp[which(temp == 'G')] = "6"
temp[which(temp == 'H')] = "7"
temp[which(temp == 'I')] = "8"
temp[which(temp == 'J')] = "9"
temp[which(temp == 'K')] = "10"
temp[which(temp == 'L')] = "11"
temp[which(temp == 'M')] = "12"
temp[which(temp == 'N')] = "13"
temp[which(temp == 'O')] = "14"
temp[which(temp == 'P')] = "15"
temp[which(temp == 'Q')] = "16"
# Se for a Q047 (acredito que seja desnecessÃ¡rio porque o cÃ³digo anterior jÃ¡ faz oq essas 5 linhas faz)
temp[which(temp == 'A')] = "0"
temp[which(temp == 'B')] = "1"
temp[which(temp == 'C')] = "2"
temp[which(temp == 'D')] = "3"
temp[which(temp == 'E')] = "4"
dataset[, i] <- as.integer(temp)
}
return(dataset)
}
removeNA <- function(dataSet){
tam.inicial <- nrow(dataSet)
for(i in seq_along(dataSet)){
dataSet <- dataSet[!is.na(dataSet[, i]), ]
#dataSet <- dataSet[attrSemNa, ]
#print(i)
}
cat("\t", tam.inicial - nrow(dataSet), " valores NA removidos.\n")
cat("\tPorcentagem de NAs removidos: ", 100 - (nrow(dataSet) * 100 / tam.inicial),"%\n")
return(dataSet)
}
removeOutliers <- function(dataSet){
inicial <- nrow(dataSet)
for(i in seq_along(dataSet[, -c(ncol(dataSet))])){
attrSemNa <- dataSet[, i][!is.na(dataSet[, i])]
# Boxplot antes de remover os Outliers
png(filename = paste(toString(names(dataSet[i])), ".png") )
boxplot(attrSemNa)
dev.off()
dataSet <- dataSet[!attrSemNa %in% boxplot.stats(attrSemNa)$out, ]
boxplot(attrSemNa)
#print(i)
}
cat("Outliers Removidos: ", inicial - nrow(dataSet), "\n")
cat("Total de instancias: ", inicial, "\n")
cat("InstÃ¢ncias atuais: ", nrow(dataSet), "\n")
cat("Numero colunas: ", ncol(dataSet), "\n")
cat("Porcentagem de outliers removidos: ", nrow(dataSet) * 100 / inicial,"%\n")
return(dataSet)
}
normalizar <- function(dataSet){
attrs <- c()
for(i in seq_along(dataSet[, -c(ncol(dataSet))])){
attrSemNA <- dataSet[, i][!is.na(dataSet[, i])]
minValue <- min(attrSemNA)
#print(minValue)
maxValue <- max(attrSemNA)
#print(maxValue)
if(maxValue - minValue != 0){
normAttr <- (attrSemNA - minValue) / (maxValue - minValue)
dataSet[, i] <- normAttr
cat("Normalizado: ", i, "\n")
}else{
attrs <- c(attrs, i)
}
}
print(attrs)
dataSet <- dataSet[ , -c(attrs)]
return(dataSet)
}
dados <- transformacao(dados)
dados <- removeNA(dados)
dados <- normalizar(dados)
dados
unique(dados$V6)
unique(dados$V16)
length(unique(dados$V16))
write.csv(dados, file = "enemNumericoPre.csv", sep = ",", row.names = FALSE)
dados
dados[, 4]
dados[, 3]
dados
#setwd("../../genic/Documents/GitHub/MATB16/Trabalho/Códigos/")
dados <- read.csv("enemNumericoPre.csv", sep = ",")
#dados
#dados <- dados[which(dados$V1 == "BA"), ]
#write.table(x = dados, file = "enem_BA.data", sep = ",")
#tmp <- dados$V16
#tmp <- sort(tmp)
#tmp
#min(tmp)
#max(tmp)
#intervalo <- ((max(tmp) - min(tmp))/3)
#minInter <- min(tmp)
for(j in c(1:13)){
tmp <- dados[, j]
for(i in 1:length(tmp)){
#inter_min <- (i * intervalo) + minInter - intervalo
#print(inter_min)
#inter_max <- (i * intervalo) + minInter
#print(inter_max)
#indices <- which(tmp >= inter_min & tmp <= inter_max)
#print(which(tmp <= 32 & tmp >= 10))
#print(length(indices))
#classes <- c("menor","mediano", "maior")
#tmp[indices] <- classes[i]
tmp[i] = toString(paste("labIA",i))
print(i)
}
dados[, j] <- tmp
}
#setwd("../../genic/Documents/GitHub/MATB16/Trabalho/Códigos/")
dados <- read.csv("enemNumericoPre.csv", sep = ",")
#dados
#dados <- dados[which(dados$V1 == "BA"), ]
#write.table(x = dados, file = "enem_BA.data", sep = ",")
#tmp <- dados$V16
#tmp <- sort(tmp)
#tmp
#min(tmp)
#max(tmp)
#intervalo <- ((max(tmp) - min(tmp))/3)
#minInter <- min(tmp)
for(j in c(1:13)){
tmp <- dados[, j]
for(i in 1:length(tmp)){
#inter_min <- (i * intervalo) + minInter - intervalo
#print(inter_min)
#inter_max <- (i * intervalo) + minInter
#print(inter_max)
#indices <- which(tmp >= inter_min & tmp <= inter_max)
#print(which(tmp <= 32 & tmp >= 10))
#print(length(indices))
#classes <- c("menor","mediano", "maior")
#tmp[indices] <- classes[i]
tmp[i] = toString(paste("labIA",i))
print(i)
}
cat("--", j)
dados[, j] <- tmp
}
dados
#setwd("../../genic/Documents/GitHub/MATB16/Trabalho/Códigos/")
dados <- read.csv("enemNumericoPre.csv", sep = ",")
#dados
#dados <- dados[which(dados$V1 == "BA"), ]
#write.table(x = dados, file = "enem_BA.data", sep = ",")
#tmp <- dados$V16
#tmp <- sort(tmp)
#tmp
#min(tmp)
#max(tmp)
#intervalo <- ((max(tmp) - min(tmp))/3)
#minInter <- min(tmp)
for(j in c(1:13)){
tmp <- dados[, j]
for(i in 1:length(tmp)){
#inter_min <- (i * intervalo) + minInter - intervalo
#print(inter_min)
#inter_max <- (i * intervalo) + minInter
#print(inter_max)
#indices <- which(tmp >= inter_min & tmp <= inter_max)
#print(which(tmp <= 32 & tmp >= 10))
#print(length(indices))
#classes <- c("menor","mediano", "maior")
#tmp[indices] <- classes[i]
tmp[i] = toString(tmp[i])
print(i)
}
cat("--", j)
dados[, j] <- tmp
}
#setwd("../../genic/Documents/GitHub/MATB16/Trabalho/Códigos/")
dados <- read.csv("enemNumericoPre.csv", sep = ",")
#dados
#dados <- dados[which(dados$V1 == "BA"), ]
#write.table(x = dados, file = "enem_BA.data", sep = ",")
#tmp <- dados$V16
#tmp <- sort(tmp)
#tmp
#min(tmp)
#max(tmp)
#intervalo <- ((max(tmp) - min(tmp))/3)
#minInter <- min(tmp)
for(j in c(1:13)){
tmp <- dados[, j]
for(i in 1:length(tmp)){
#inter_min <- (i * intervalo) + minInter - intervalo
#print(inter_min)
#inter_max <- (i * intervalo) + minInter
#print(inter_max)
#indices <- which(tmp >= inter_min & tmp <= inter_max)
#print(which(tmp <= 32 & tmp >= 10))
#print(length(indices))
#classes <- c("menor","mediano", "maior")
#tmp[indices] <- classes[i]
tmp[i] = toString(tmp[i])
print(i)
}
cat("--", j)
dados[, j] <- tmp
}
dados
write.csv(x = dados, file = "enem_Ba_nominal.csv", sep = ",", row.names = FALSE)
#setwd("../../genic/Documents/GitHub/MATB16/Trabalho/Códigos/")
dados <- read.csv("enemNumericoPre.csv", sep = ",")
#dados
#dados <- dados[which(dados$V1 == "BA"), ]
#write.table(x = dados, file = "enem_BA.data", sep = ",")
#tmp <- dados$V16
#tmp <- sort(tmp)
#tmp
#min(tmp)
#max(tmp)
#intervalo <- ((max(tmp) - min(tmp))/3)
#minInter <- min(tmp)
for(j in c(1:13)){
tmp <- dados[, j]
for(i in 1:length(tmp)){
#inter_min <- (i * intervalo) + minInter - intervalo
#print(inter_min)
#inter_max <- (i * intervalo) + minInter
#print(inter_max)
#indices <- which(tmp >= inter_min & tmp <= inter_max)
#print(which(tmp <= 32 & tmp >= 10))
#print(length(indices))
#classes <- c("menor","mediano", "maior")
#tmp[indices] <- classes[i]
tmp[i] = paste("a", toString(tmp[i]))
print(i)
}
cat("--", j)
dados[, j] <- tmp
}
#setwd("../../genic/Documents/GitHub/MATB16/Trabalho/Códigos/")
dados <- read.csv("enemNumericoPre.csv", sep = ",")
#dados
#dados <- dados[which(dados$V1 == "BA"), ]
#write.table(x = dados, file = "enem_BA.data", sep = ",")
#tmp <- dados$V16
#tmp <- sort(tmp)
#tmp
#min(tmp)
#max(tmp)
#intervalo <- ((max(tmp) - min(tmp))/3)
#minInter <- min(tmp)
for(j in c(1:13)){
tmp <- dados[, j]
for(i in 1:length(tmp)){
#inter_min <- (i * intervalo) + minInter - intervalo
#print(inter_min)
#inter_max <- (i * intervalo) + minInter
#print(inter_max)
#indices <- which(tmp >= inter_min & tmp <= inter_max)
#print(which(tmp <= 32 & tmp >= 10))
#print(length(indices))
#classes <- c("menor","mediano", "maior")
#tmp[indices] <- classes[i]
tmp[i] = paste("a", toString(tmp[i]))
print(i)
}
cat("--", j)
dados[, j] <- tmp
}
write.csv(x = dados, file = "enem_Ba_nominal.csv", sep = ",", row.names = FALSE)
dados
=== Run information ===
Scheme:       weka.classifiers.lazy.IBk -K 3 -W 0 -A "weka.core.neighboursearch.LinearNNSearch -A \"weka.core.EuclideanDistance -R first-last\""
Relation:     enemNumericoPre
Instances:    85467
Attributes:   13
V2
V3
V4
V5
V6
V8
V10
V11
V12
V13
V14
V15
V16
Test mode:    5-fold cross-validation
=== Classifier model (full training set) ===
IB1 instance-based classifier
using 3 nearest neighbour(s) for classification
Time taken to build model: 0.61 seconds
=== Cross-validation ===
=== Summary ===
Correlation coefficient                  0.5537
Mean absolute error                     99.0515
Root mean squared error                132.1903
Relative absolute error                 88.6266 %
Root relative squared error             86.211  %
Total Number of Instances            85467
